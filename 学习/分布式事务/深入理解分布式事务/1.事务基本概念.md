# 第一章 事务的基本概念

事务一般指的是逻辑上的一组操作, 或者作为单个逻辑单元执行的一系列操作, 同属于一个事务的操作会作为一个整体提交给系统, 这些操作妖魔全部执行成功, 要么全部执行失败.

## 事务的特性

-   atomic 原子性
-   consistency 一致性
-   isolation 隔离性
-   durability 持久性

A 保证了粒度, C 保证了粒度的正确性, I 保证了多个事务可以并行, D 保证了可以延伸到未来.

A -> 要么全部执行成功, 要么全部执行失败.
C -> 前后数据处于一致的状态.
I -> 多个事务可以并行.
D -> 更改可以被持久化.

## 事务的类型

1. 扁平事务
2. 带有保存点的扁平事务
3. 链式事务
4. 嵌套事务
5. 分布式事务

### 扁平事务

最简单的一种, 但在实际生产环境中, 使用最频繁的事务. 所有的操作都处于同一层次, 其由 begin work 开始, 由 commit work 或 rollback work 结束, 其间的操作都是原子的, 要么都执行, 要么都回滚. 因此扁平事务是应用程序成为原子操作的基本组成模块.

![扁平事务的三种情况](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-13/pic_1657693617276-18.png)

扁平事务的主要限制就是不能提交或者回滚事务的某一部分, 或分几个步骤提交.

### 带有保存点的扁平事务

除了支持扁平事务支持的操作外, 允许在事务执行过程中回滚到同一事务中较早的一个状态. 这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效, 放弃整个事务不合乎要求, 开销也比较大. 保存点用来通知系统应该记住事务当前的状态, 以便当之后发生错误时, 事务能回到保存点当前的状态.

保存点时递增的.

当发生系统崩溃时, 所有的保存点都将消失, 因为其保存点是易失的, 而非持久的. 这意味这当进行恢复时, 事务需要从开始处重新执行, 而不能从最近的一个保存点继续执行.

### 链式事务

在提交一个事务时, 时方不需要的数据对象, 将必要的处理上下文隐式地传递给下一个要开始的事务. 注意, 提交事务操作和开始下一个事务操作将合并为一个原子操作. 这意味着下一个事务将看到上一个事务的结果, 就好像在一个事务中进行的一样.

![链式事务](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-13/pic_1657694198517-31.png)

链事务中的回滚仅限于当前事务, 只能恢复到最近一个的保存点, 对于锁的处理, 两者也不相同. 链事务在执行 commit 后即释放了当前事务锁持有的锁, 而带有保存点的扁平事务不影响迄今为止所持有的锁.

### 嵌套事务

层次结构框架, 由一个顶层事务控制着各个层次的事务. 顶层事务之下嵌套的事务被成为自事务, 其控制每一个局部的变换.

![嵌套事务](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-13/pic_1657694414056-48.png)

Moss 对嵌套事务的定义

<!-- -  -->

主流关系性数据库中, mysql 不支持原生的嵌套事务, sql server 支持.

### 分布式事务

通常是一个在分布式环境下运行的扁平事务, 因此需要根据数据所在位置访问网络中的不同节点.

事务的参与者, 事务所在的服务器, 涉及的资源服务器以及事务管理器等分别位于不同分布式系统的不同服务或数据库节点上. 简单来说, 分布式事务就是一个在不同环境下(比如不同的数据库, 不同的服务器) 下运行的整体事务. 这个整体事务包含一个或者多个分支事务, 并且整体事务中的所有分支事务要么全部提交成功, 妖魔全部提交失败.

## 本地事务

在常见的计算机系统和应用系统中，很多事务是通过关系型数据库进行控制的。这种控制事务的方式是利用数据库本身的事务特性来实现，而在这种实现方式中，数据库和应用通常会被放在同一台服务器中，因此，这种基于关系型数据库的事务也可以称作本地事务或者传统事务。

```sql
transaction begin
insert into 表名 (字段名列表) values (值列表)
update 表名 set 字段名 = 字段值 where id = id值
delete from 表名 where id = id值
transaction commit/rollback
```

本地事务典型特征

-   一次事务过程中只能链接一个支持事务的数据库, 这里的数据库一般指的是关系性数据库
-   事务的执行结果必须满足 ACID 特性
-   事务的执行过程会用到数据库本身的锁机制

### 执行流程

1. 客户端开始事务操作之前, 需要开启一个连接会话
2. 开始会话后, 客户端发起开启事务的指令
3. 事务开启后, 客户端发送各种 sql 语句处理数据
4. 正常情况下, 客户端会发起提交事务的指令, 如果发生异常情况, 客户端会发起回滚事务指令
5. 完成之后, 关闭会话

本地事务是由资源管理其在本地进行管理的.

优点:

1. 严格支持 ACID 特性
2. 事务可靠, 一般不会出现异常情况
3. 本地事务的操作效率比较高
4. 事务的状态可以只在数据库中进行维护, 上层的应用不必理会事务的具体状态
5. 应用的编程模型比较简单, 不会涉及复杂的网络通信

缺点:

1. 不具备分布式事务的处理能力
2. 一次事务过程中只能连接一个支持事务的数据库, 即不能用于多个事务性数据库

## mysql 事务基础

并发带来的问题

并发事务带来的问题包括更新丢失(脏写), 脏读, 不可重复读, 幻读

### 更新丢失 (赃写)

当两个或两个以上的事务选择数据库中的同一行数据，并基于最初选定的值更新该行数据时，因为每个事务之间都无法感知彼此的存在，所以会出现最后的更新操作覆盖之前由其他事务完成的更新操作的情况。也就是说，对于同一行数据，一个事务对该行数据的更新操作覆盖了其他事务对该行数据的更新操作。

例如，张三的账户余额是 100 元，当前有事务 A 和事务 B 两个事务，事务 A 是将张三的账户余额增加 100 元，事务 B 是将张三的账户余额增加 200 元。起初，事务 A 和事务 B 同时读取到张三的账户余额为 100 元。然后，事务 A 和事务 B 将分别更新张三的银行账户余额，假设事务 A 先于事务 B 提交，但事务 A 和事务 B 都提交后的结果是张三的账户余额是 300 元。也就是说，后提交的事务 B 覆盖了事务 A 的更新操作。

更新丢失（脏写）本质上是写操作的冲突，解决办法是让每个事务按照串行的方式执行，按照一定的顺序依次进行写操作。

### 赃读

一个事务正在对数据库中的一条记录进行修改操作，在这个事务完成并提交之前，当有另一个事务来读取正在修改的这条数据记录时，如果没有对这两个事务进行控制，则第二个事务就会读取到没有被提交的脏数据，并根据这些脏数据做进一步的处理，此时就会产生未提交的数据依赖关系。我们通常把这种现象称为脏读，也就是一个事务读取了另一个事务未提交的数据。

例如，当前有事务 A 和事务 B 两个事务，事务 A 是向张三的银行账户转账 100 元，事务 B 是查询张三的账户余额。事务 A 执行转账操作，在事务 A 未提交时，事务 B 查询到张三的银行账户多了 100 元，后来事务 A 由于某些原因，例如服务超时、系统异常等因素进行回滚操作，但事务 B 查询到的数据并没有改变。此时，事务 B 查询到的数据就是脏数据。

脏读本质上是读写操作的冲突，解决办法是先写后读，也就是写完之后再读。

### 不可重复读

一个事务读取了某些数据，在一段时间后，这个事务再次读取之前读过的数据，此时发现读取的数据发生了变化，或者其中的某些记录已经被删除，这种现象就叫作不可重复读。即同一个事务，使用相同的查询语句，在不同时刻读取到的结果不一致。

例如，当前有事务 A 和事务 B 两个事务，事务 A 是向张三的银行账户转账 100 元，事务 B 是查询张三的账户余额。第一次查询时，事务 A 还没有转账，第二次查询时，事务 A 已经转账成功，此时，就会导致事务 B 两次查询结果不一致。

不可重复读本质上也是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。

### 幻读

一个事务按照相同的查询条件重新读取之前读过的数据，此时发现其他事务插入了满足当前事务查询条件的新数据，这种现象叫作幻读。即一个事务两次读取一个范围的数据记录，两次读取到的结果不同。

例如，当前有事务 A 和事务 B 两个事务，事务 A 是两次查询张三的转账记录，事务 B 是向张三的银行账户转账 100 元。事务 A 第一次查询时，事务 B 还没有转账，事务 A 第二次查询时，事务 B 已经转账成功，此时，就会导致事务 A 两次查询的转账数据不一致。

幻读本质上是读写操作的冲突，解决办法是先读后写，也就是读完之后再写。

很多人不懂不可重复读和幻读到底有何区别。这里，我们简单介绍一下。

1）不可重复读的重点在于更新和删除操作，而幻读的重点在于插入操作。
2）使用锁机制实现事务隔离级别时，在可重复读隔离级别中，SQL 语句第一次读取到数据后，会将相应的数据加锁，使得其他事务无法修改和删除这些数据，此时可以实现可重复读。这种方法无法对新插入的数据加锁。如果事务 A 读取了数据，或者修改和删除了数据，此时，事务 B 还可以进行插入操作，导致事务 A 莫名其妙地多了一条之前没有的数据，这就是幻读。
3）幻读无法通过行级锁来避免，需要使用串行化的事务隔离级别，但是这种事务隔离级别会极大降低数据库的并发能力。
4）从本质上讲，不可重复读和幻读最大的区别在于如何通过锁机制解决问题。

另外，除了可以使用悲观锁来避免不可重复读和幻读的问题外，我们也可以使用乐观锁来处理，例如，MySQL、Oracle 和 PostgreSQL 等数据库为了提高整体性能，就使用了基于乐观锁的 MVCC（多版本并发控制）机制来避免不可重复读和幻读。

### mysql 事务隔离级别

四种事务隔离级别

-   read uncommitted (读未提交)
-   read committed (读已提交)
-   repeatable read (可重复读)
-   serializable (串行化)

innodb 默认使用 repeatable read 级别.

### mysql 中各种事务隔离级别的区别

| 事务隔离级别 | 赃读  | 不可重复读 | 幻读  |
| ------------ | :---: | :--------: | :---: |
| 读未提交     |   😥   |     😥      |   😥   |
| 读已提交     |   🚫   |     😥      |   😥   |
| 可重复读     |   🚫   |     🚫      |   😥   |
| 串行化       |   🚫   |     🚫      |   🚫   |

### mysql 中锁分类

性能
- 乐观锁
- 悲观锁

操作类型
- 读
- 写

数据粒度
- 表
- 行
- 页面

更细粒度
- 间隙
- 临键

1）从性能上看，MySQL中的锁可以分为悲观锁和乐观锁，这里的乐观锁是通过版本对比来实现的。
2）从对数据库的操作类型上看，MySQL中的锁可以分为读锁和写锁，这里的读锁和写锁都是悲观锁。
3）从操作数据的粒度上看，MySQL中的锁可以分为表锁、行锁和页面锁。
4）从更细粒度上看，MySQL中的锁可以分为间隙锁和临键锁。

### 乐观锁和悲观锁

- 悲观锁
顾名思义，悲观锁对于数据库中数据的读写持悲观态度，即在整个数据处理的过程中，它会将相应的数据锁定。在数据库中，悲观锁的实现需要依赖数据库提供的锁机制，以保证对数据库加锁后，其他应用系统无法修改数据库中的数据。
在悲观锁机制下，读取数据库中的数据时需要加锁，此时不能对这些数据进行修改操作。修改数据库中的数据时也需要加锁，此时不能对这些数据进行读取操作。
- 乐观锁
悲观锁会极大地降低数据库的性能，特别是对长事务而言，性能的损耗往往是无法承受的。乐观锁则在一定程度上解决了这个问题。
顾名思义，乐观锁对于数据库中数据的读写持乐观态度，即在整个数据处理的过程中，大多数情况下它是通过数据版本记录机制实现的。
实现乐观锁的一种常用做法是为数据增加一个版本标识，如果是通过数据库实现，往往会在数据表中增加一个类似version的版本号字段。在查询数据表中的数据时，会将版本号字段的值一起读取出来，当更新数据时，会令版本号字段的值加1。将提交数据的版本与数据表对应记录的版本进行对比，如果提交的数据版本号大于数据表中当前要修改的数据的版本号，则对数据进行修改操作。否则，不修改数据表中的数据。

### 间隙锁和临键锁

- 间隙锁
在MySQL中使用范围查询时，如果请求共享锁或排他锁，InnoDB会给符合条件的已有数据的索引项加锁。如果键值在条件范围内，而这个范围内并不存在记录，则认为此时出现了“间隙（也就是GAP）”。InnoDB存储引擎会对这个“间隙”加锁，而这种加锁机制就是间隙锁（GAPLock）。
说得简单点，间隙锁就是对两个值之间的间隙加锁。MySQL的默认隔离级别是可重复读，在可重复读隔离级别下会存在幻读的问题，而间隙锁在某种程度下可以解决幻读的问题。

- 临键锁
临键锁（Next-Key Lock）是行锁和间隙锁的组合，例如上面例子中的区间(3,20]就可以称为临键锁。
