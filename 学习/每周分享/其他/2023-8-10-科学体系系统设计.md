# 科学体系系统设计

该系统本质为套壳或者二次开发的系统, 即有属于系统本身需要实现的一些功能, 同时也有基于其他原有开源系统的调用.

## 系统概述

系统所要实现的功能点主要包含有:
- 登录, 注册
- 实验数据的录入, 筛选查询, 可视化
- 医学数据的上传, 标记, 可视化, 分析
- 用户个人的上传, 下载, 目录查询
- 公用的上传, 下载, 目录查询
- 任务的执行, 调度, 监控 
- 围绕上述功能其他的一些功能点

### 登录, 注册

登录和注册属于一般性系统的通用功能, 这里使用 jwt token 来完成实现, 但是还有一些其他的额外的操作, 之后再做讨论. jwt token 的实现原理即通过用户名和密码或者其他信息完成用户身份的验证之后给予其凭证, 而该凭证又只能进行校验, 基本上使用的是散列算法进行实现, 散列过程中还需要一个对应的 secret 来保证之后对散列值的反向序列化, 如果没有 secret 则可以认为原数据到散列值的是具有单向性的, 不能通过散列值反推原数据, 但是可以通过原数据计算散列值. 而引入 secret 之后, 拿该 secret 就可以对散列值进行反向散列拿到原来的数据. 纵观该过程, 如果将散列的过程识为加密, 而反散列认为是解密, 很清晰加解密所凭借的 secret 是一致的. 对应的算法应是对称加密算法. 当然 jwt token 的内容并不全是没有 secret 就不可知的, 其中包含了一些元数据, 这里并不再做详细讨论. 

前者讨论完之后, 后者即一些其他的额外的操作. 所谓额外的操作是什么呢？ 即需要去依赖的一个开源系统中做一些初始化的工作, 为什么需要去依赖的系统中做初始化工作, 因为系统内部的一些功能需要跳转到依赖的系统中完成, 比如数据的标注, 图像的标注等, 当跳转时需要用户完成登录才能操作. 很显然上述的现象暴露出一个问题, 多个系统中的用户实际上映射的是同一个用户, 即一个用户在不同系统中同时拥有身份, 理想的情况是使用同一的验证入口统合多个系统, 逻辑上即在不同的系统登录入口架一个登录功能. 实际情况还需要考虑内部系统的身份沟通, 比如在一个 A 系统中有身份之后, 在同属信任的 B 系统中是否需要再次登录？以上简要探讨, 实际的问题还需要更多更详细的考虑. 回到依赖的系统中去, 该系统虽然支持 sso 功能, 即作为一个服务提供者, 外部作为身份提供者即可实现. 举个例子, 比如在 qq 注册一个账号, 而通过该账号可以登录 A 网站, 而该网站就是服务提供者, 而 qq 作为身份来源就是身份提供者. 可以发现中间沟通的内容为身份, 身份提供者为上游, 服务提供者为下游. 这个时候就需要系统本身具有身份提供者的功能, 而该功能的实现相对于系统的调用和同步来说比较复杂. 同时需要注意的是, 系统本身和依赖的系统之间的关系是强依赖的, 而不是独立的, 前者的实现重度依赖后者, 这意味着直接调用或许更合理, 因为本质上是一个大的系统, 而不是两个独立的系统. 继续回到系统调用的讨论中, 这里系统调用并非操作系统术语中的系统调用, 本质上是远程调用. 针对该远程调用的讨论后续在系统设计中再做详细讨论. 这里总论该功能的实现要点和考虑.

### 实验数据的录入, 筛选查询, 可视化

实验数据的录入, 筛选查询, 可视化是系统的核心功能, 实验数据是很大, 小的几百 M, 大的几十 G. 大文件上传的效率底线为程序的处理过程, 上限则为带宽的限制. 前者角度在系统整体上考虑的, 因为文件处理如果不合理, 比如同步处理, 直接导致系统可用性. 而后者则为网络的基本限制. 前者的处理方式可以诉诸流的操作, 将大文件的上传以及下载划分为小部分, 使用较少内存完成大文件的操作. 而将文件流的划分以及 buffer 的转移则可以使用基础库来完成. 后者的处理方式需要对部署环境带宽的要求来完成. 

筛选查询的操作难点在于筛选条件的构造和筛选条件转化为查询语句, 筛选条件最低要求则为满足业务筛选, 高一些的则站在所有实体的角度, 以及实体之间的关系, 只要实现所有实体的各个角度查询以及实体之间的关系查询, 则可以在更高层次满足最低的要求. 其中可以考虑 autoQuery 或者其他技术栈的相关操作, 本质上是构造一套查询语言来映射向底层操作. 这是一劳永逸的方法, 具备可移植性, 之后的系统面向的问题则转化为查询语句的审计来及时发现或者监控到不满足期待性能的语句来进行针对性的优化, 这又要求在满足整体规则下预留自定义的转化规则来完成后续的优化. 实际开发中为了快速迭代或者工作成效的问题大多选择以最低满足业务筛选的目的来构造相关功能, 实际上该系统的实现也是如此. 但是在实现过程中依旧会面临杂多复杂的筛选条件的处理以及最终目标产物的构造, 如果筛选条件属于表现层或者 ui 层次的数据, 而由此产生的查询产物属于业务层次或者数据持久化的层次, 其中主要的过程在于产物的类型, 因为该类型可能不仅与技术栈强相关, 也会收到 orm 的影响. 在该系统的实现上我们选择的产物为 linq, 通过查询条件的定义以及将转化过程放到定义中实现, 来完成面向 ui 的查询条件的转化, 最终落实在目标数据的获取.

可视化功能如果排除既定规则的限制, 比如获取所有病人男生女生的数量以及比例. 该条件是主要内容, 所关注的要点在于以该条件为中心的数据获取和进一步的数据处理, 比如数据遍历从而得到目标数据的相关数据. 

以上为三个系统中的要点的相关思考, 其中主要关注在复杂的筛选查询.

## 系统设计

以下为系统设计的相关内容, 包含技术栈, 数据库选择, 基本功能实现及通用类设计, 重难点, 运维及部署.

技术栈选择为 .net, 版本为目前较新的版本, orm 使用 ef core 也是较新的版本, 其他杂七杂八的选择有 linq 扩展(处理复杂查询映射关系时很重要), jwt 相关组件(用户认证), Swashbuckle(openApi 生成前端文档), 基本的请求库 Flurl.Http

### 数据库选择

因为需要额外的信息存储, 比如实验数据, 文件信息, 用户数据等, 因此需要持久化数据, 数据库使用 pgsql, 基本任一主流关系或者非关系性数据库都能满足系统要求, 此处主要考虑的就是个人喜好以及编程时的风格选择.

### 基本功能实现及通用类设计

有些实体需要 crud 的基本功能, 考虑到公用性, 因此需要通用的基础服务, 方便基本功能的快速构建. 而基础类的 crud 中是否全都需要, 换言之, 有些实体只需要更新, 有些实体因为业务比较简单只需要初始化数据进行相关查询, 而并不会进行数据的相关更改, 因此需要考虑 crud 基础服务的粒度可细, 只要粒度可细, 就可以为不同实体选择需要的类进行继承, 实际上实现并没进行相关实现, 而只是大略继承了 crud 整体的功能, 这也意味着实现上的冗余和繁多. 如果进行 crud 细粒度的拆分, 可以参考的设计 [ABP](https://www.cnblogs.com/txw999/p/6972173.html), [nestjsx crud](https://github.com/nestjsx/crud/wiki/Controllers#options). 需要考虑的是面向服务对控制器, 面向控制器不提供服务, 还是两者都有. 当面向服务对控制器提供服务时, 需要在控制器中使用该服务, 该服务是继承还是组合? 优势为何? 该方式对于用户实现是否有冗余? 这些都是需要考虑的重要问题. 实现方式变多, 意味着可选择性高, 需要逐一对比, 以凸显出其中不足.

### 重难点

重难点实现主要包含复杂查询, 外部系统调用, 后台程序处理, 以下逐一进行说明

#### 复杂查询的实现

复杂查询所以复杂, 体现在查询条件的杂多, 当查询条件比较多的时候, 查询条件到查询语句的转化就成为主要考虑的问题. 查询条件转换为查询语句可以手动约定转换逻辑通过该逻辑转换为查询语句需要的数据, 查询语句可以简单也可以复杂, 简单的形如 id 字段, 复杂的形如一系列查询条件, 目标查询语句的选择可能是一些转换必须的数据, 也可以是包含数据的行为, 形如 linq. 如果将复杂条件通过约定的逻辑转换为 linq 的话, 之后对数据库的操作则只需要进行 linq 查询即可. 额外需要考虑的是有些并不属于数据的筛选查询条件, 形如分页, 页码等数据, 但是对结果有重要影响的数据是否需要单独剥离出来, 如果剥离出来查询和查询分页既可以分离开来, 能保证两者都可以, 且查询分页还能复用查询的查询产物即 linq 语句, 只需要额外再加入相关逻辑即可.

上述功能需要对 linq 的相关组合, 复杂逻辑处理, 而这些处理则借助第三方的扩展来实现该功能. 即 `System.Linq.Dynamic.Core`.

#### 外部调用, 系统集成

#### 后台程序处理

## 运维及部署

### 测试环境

### 生产环境


