# C++ 并发内存模型-为什么需要内存模型

- 运行的程序是我我们写的程序吗? 
- 代码的编写顺序, 是实际执行顺序?
- 编译器都对我们的程序做了什么?
- 操作系统会怎么处理以及运行我们的程序?

## 编译器

![GCC 与 gcc 的逻辑结构](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663951204756-22.png)  

代码的优化部分主要体现在 IR 部分, 借由流水线的处理来完成各种优化


### 编译器的优化
编译器都会对我们的程序进行那些相关优化

[gcc 编译器优化选项](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)

1. [乘法的转换](https://godbolt.org/z/feceYcb5K)

```c++
// 开启 -O3 -march=haswell 之后在每次循环中会被优化未 +1234
#include <iostream>

int main()
{
    for (int i = 0; i < 100; ++i)
    {
        std::cout << i * 1234 << std::endl;
    }
    return 0;
}
```

2. [恒定折叠](https://godbolt.org/z/GvPXFy) 
> 编译器采用可以在编译时计算其值的表达式，并直接用计算结果替换它们.

3. 不断传播
> 编译器跟踪值的来源，并利用知道某些值对于所有可能的执行都是恒定的.

4. 公共子表达式消除
> 重复的计算被重写为计算一次并复制结果.

5. 死代码删除
> 在进行了许多其他优化之后，代码中可能存在对输出没有影响的区域，这些可以被删除。这包括未使用值的加载和存储，以及整个函数和表达式.

6. 指令选择
> 这本身并不是一种优化，但是当编译器采用程序的内部表示并生成 CPU 指令时，它通常有大量等效的指令序列可供选择。做出正确的选择需要编译器对其目标处理器的体系结构有很多了解.

7. 循环不变的代码移动
> 编译器识别出循环中的某些表达式在该循环期间是恒定的，并将它们移出循环。最重要的是，编译器能够将循环不变条件检查移出循环，然后复制循环体两次：如果条件为真，则复制一次，如果条件为假，则复制一次。这可以导致进一步的优化.

8. 窥孔优化
> 编译器采用短指令序列并在这些指令之间寻找局部优化.

9. 尾调用去除
> 以调用自身结束的递归函数通常可以重写为循环，从而减少调用开销并减少堆栈溢出的机会.

### 大多数程序都是多线程程序
为什么使用多线程-多核心计算机系统架构的产生
为了充分使用计算资源, 增加程序的效率(速度, 处理能力)
对于多线程程序常见的问题, 多线程问题为什么会产生
多线程程序中的常见问题：
- 不可见(多线程程序之间共享变量)
- 原子性(对于一些数值的操作看似是原子的, 实际上会执行多个隐含步骤)
- 有序性(多线程中每个线程看到的都是自己的内存序列, 对于多线程之间的沟通需要保证沟通的有序性)

永不终止的循环 - 可见性问题
加加减减 5 10 15 - 原子性
有序性问题
> [仓库地址](https://github.com/wedreamer/cpp-memory-model-test-demo)

## 操作系统
- 程序执行流水线
- 体系结构对程序执行的一些影响

### 程序执行流水线

编译(可能会有编译器优化导致的程序重排) -> 连接 -> 执行

执行过程操作系统都做了什么
- 进程创建
- 进程调度/执行(并行编程, 多线程和多处理都要求将软件分解未可以由操作系统调度, 从而可被并发处理的执行单元)
- 进程终止

### 体系结构对程序执行的一些影响

体系结构
- 基本的处理器体系结构
![简单体系结构](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663961122859-49.png)  
- cpu 指令集
![cpu 指令集](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663961229835-3.png)  
- 主存是关键
![主存](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663961262228-16.png)  
- 寄存器
- 多级流水线(现代编译器已经引入了流水线指令部件 -> 现代体系结构的优化编译器#1.2)
导致的结果, 后写的程序先执行
- cpu 缓存

![cpu cache 图](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663962469427-24.png)  

运行在其他核心上的任务读取不到当前核心的 cpu cache, 不同 cpu cache 会发生冲突, cpu cache 也可能会于内存 cache 发生冲突

> MESI 协议 
    > 引入缓存的副作用在于同一份数据可能保存了副本，一致性该如何保证呢？
> - Modiﬁed - 要向其它 CPU 发送 cache line 无效消息，并等待 ack. 表示该缓存行有效，但是是被更改过的，与内存中的数据并不一致，并且该缓存行只存在于本缓存中（举例：我们有三个CPU，每个CPU都有自己的缓存区域，那么M表示CPU-A从内存中取到了数据，其他CPU并没有取此数据（只存在于本缓存中），CPU-A还把该数据进行了更改，导致与内存中的源数据并不一致）
> - Exclusive - 独占、即将要执行修改. 表示该缓存行有效，数据和内存中的一致（干净），并且数据只存在于本缓存行中
> - Shared - 共享、一般读取时的初始状态. 表示该缓存行有效，数据和内存中的一致，并且数据也同时存在于其他缓存中
> - Invalid - 一旦发现数据无效，需要重新加载数据. 该缓存行数据无效

> 思考: cpu cache 与 主存 之间的数据差异(同步策略)
> 思考: cpu 之间 cache 之间的数据差异(同步策略)
> 各个状态之间的变换

![cache 状态图](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663996868603-49.png)  


![cache 事件](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663996851875-2.png)  


- 流水线
流水线在 CPU 的一个时钟周期内会执行多个指令的不同部分

非流水线操作
```cpp
// 假设有三条指令
‐‐‐|‐‐‐|‐‐‐|
1   2   3
```
流水线操作
```cpp
A|B|C| // 1
  A|B|C| // 2
    A|B|C| // 3
```

在按序执行中，一旦遇到指令依赖的情况，流水线就会停滞
如果采用乱序执行，就可以跳到下一个非依赖指令并发布它。这样，执行单元就可以总是处于工作状态，把时间浪费减到最少

例如： //3 会被重排到 //2 之前，以减少 //2 引起的流水线停滞

```cpp
x=1 //1
y=x+1 //2
z=3 //3
```

并发所带来的一些问题
- 任务之间的通信

![进程](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663961530962-22.png)  
![线程](http://images.shubuzuo.top/2022-09/2022-09-24/pic_1663961582578-21.png)

- 多个任务对数据或资源的并发访问
- 并发执行的任务之间的关系
- 任务之间的资源争夺
- 可靠的, 可重现的调试和测试

todo: 并发内存模型
用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让语言程序在各种平台下都能达到一致的并发效果。

内存模型牵涉两个方面：基本结构和并发。基本结构关系到整个程序在内存中的布局。它对并发很重要，尤其是在我们分析底层原子操作的时候，所以我从基本结构开始讲解。就C++而言，归根结底，基本结构就是对象和内存区域。


<!-- ## 并发内存模型
- 并发内存模型的提出
- 并发内存模型都约定了什么

### 并发内存模型的提出

### 并发内存模型都约定了什么 -->

## 参考
[CppCon 2017: Matt Godbolt “What Has My Compiler Done for Me Lately? Unbolting the Compiler's Lid”](https://www.youtube.com/watch?v=bSkpMdDe4g4)
[深入分析 gcc](https://hs9t5hggzr.feishu.cn/file/boxcn60XivhSlk9heEns8ARAEJd)
[C++ 编译器中的优化](https://queue.acm.org/detail.cfm?id=3372264)
[why-dont-c-compilers-do-better-constant-folding](https://stackoverflow.com/questions/52113522/why-dont-c-compilers-do-better-constant-folding)
[Optimizations in C++ Compilers](https://m-cacm.acm.org/magazines/2020/2/242347-optimizations-in-c-compilers/fulltext?mobile=true)
[c++ 多核高级编程](https://hs9t5hggzr.feishu.cn/file/boxcnPvgoYdpLPk7zWEhi3XNdzb)
[现代体系结构的优化编译器](https://hs9t5hggzr.feishu.cn/file/boxcnCaQfrfHig3rlOAZqNYTP4M)
[带你了解缓存一致性协议 MESI](https://zhuanlan.zhihu.com/p/125736342)
[c++ 并发编程实战](https://book.douban.com/subject/35653912/)
[图解MESI（缓存一致性协议）](https://blog.csdn.net/qq_18515155/article/details/122172842)
[MESI 缓存一致性协议](https://www.cnblogs.com/wwy-gongqr/p/15516378.html)
[CPU缓存一致性协议(MESI)](https://zhuanlan.zhihu.com/p/467782159)

## notes
持续更新, 修改, 迭代
