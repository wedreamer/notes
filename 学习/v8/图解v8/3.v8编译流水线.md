# v8 编译流水线

## 运行时环境

运行时环境 -- 解析 -- 生成字节码 -- 解释执行 -- 编译执行

宿主环境会提供运行时环境, 比如浏览器或者 nodejs. 包含 

- 事件循环
- 消息队列
- 堆栈
- 等

### 堆空间, 栈空间

栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，在前面的课程中我们也讲过，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。

### 全局执行上下文和全局作用域

当 V8 开始执行一段可执行代码时，会生成一个执行上下文。V8 用执行上下文来维护执行当前代码所需要的变量声明、this 指向等。

执行上下文中主要包含了三部分，变量环境、词法环境、和 this 关键字。

而词法环境中，则包含了使用 let、const 等变量的内容。

![执行上下文](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-26/pic_1658837955338-11.png)  

全局执行上下文在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了。

### 构造事件循环系统

V8 还需要有一个主线程，用来执行 JavaScript 和执行垃圾回收等工作。V8 是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程，V8 所执行的代码都是在宿主的主线程上执行的。

## 机器代码

## 堆和栈

因为解释执行和直接执行二进制代码都使用了堆和栈，虽然它们在执行细节上存在着一定的差异，但是整体的执行架构是类似的。

### 为什么使用栈结构来管理函数调用

1. 第一个特点是函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数；
2. 第二个特点是函数具有作用域机制，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们也称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

## 延迟解析

其中编译过程是指 V8 将 JavaScript 代码转换为字节码或者二进制机器代码的阶段，而执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段。

![代码执行](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-26/pic_1658838638724-30.png)  

在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码

如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间
解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存

所有主流的 JavaScript 虚拟机都实现了惰性解析。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。

### 惰性解析的过程

### js 闭包的特性

- 可以在 JavaScript 函数内部定义新的函数；
- 内部函数中访问父函数中定义的变量；
- 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值;

### 预解析器如何解决闭包所带来的问题

V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个。

1. 判断当前函数是不是存在一些语法上的错误
2. 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

## 字节码

字节码，是指编译过程中的中间代码，你可以把字节码看成是机器代码的抽象，在 V8中，字节码有两个作用：

1. 解释器可以直接解释执行字节码
2. 优化编译器可以将字节码编译为二进制代码，然后再执行二进制机器代码

![早期 v8 执行流水线](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-26/pic_1658839231411-31.png)  

- 基线编译器: 负责将 js 代码编译为没有优化过的机器代码
- 优化编译器: 负责将一些热点代码优化为执行效率更高的机器代码

### 机器代码缓存

### 字节码降低了内存占用

### 字节码如何提升代码启动速度

解释器可以快速生成字节码，但字节码通常效率不高。 相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码，这正是 V8 在使用的模型。它的解释器叫 Ignition，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。

### 字节码如何降低代码的复杂度

字节码是中间代码, 中间代码是对所有平台的抽象, 借助中间代码可以生成任一平台的机器代码.

## 字节码

V8 执行一段 JavaScript 代码时，会先对 JavaScript 代码进行解析 (Parser)，并生成为 AST 和作用域信息，之后 AST 和作用域信息被输入到一个称为 Ignition 的解释器中，并将其转化为字节码，之后字节码再由 Ignition 解释器来解释执行。

## 隐藏类

V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。

JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的
- 对象创建好了之后就不会添加新的属性
- 对象创建好了之后也不会删除属性

V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点
1. 对象中所包含的所有的属性
2. 每种类型相对于对象的偏移量

有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对于的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。

有了 map 之后，当你再次使用 point.x 访问 x 属性时，V8 会查询 point 的 map 中 x 属性相对 point 对象的偏移量，然后将 point 对象的起始位置加上偏移量，就得到了 x 属性的值在内存中的位置，有了这个位置也就拿到了 x 的值，这样我们就省去了一个比较复杂的查找过程。

### 多个对象共用一个隐藏类

每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处
1. 减少隐藏类的创建次数，也间接加速了代码的执行速度
2. 减少了隐藏类的存储空间

- 相同的属性名称
- 相等的属性个数

### 重新构建隐藏类

JavaScript 依然是动态语言，在执行过程中，对象的形状是可以被改变的，如果某个对象的形状改变了，隐藏类也会随着改变，这意味着 V8 要为新改变的对象重新构建新的隐藏类，这对于 V8 的执行效率来说，是一笔大的开销。

### 最佳实践

如果对象的形状没有发生改变，那么该对象就会一直使用该隐藏类；
如果对象的形状发生了改变，那么 V8 会重建一个新的隐藏类给该对象。

1. 使用字面量初始化对象时，要保证属性的顺序是一致的。
2. 尽量使用字面量一次性初始化完整对象属性。
3. 尽量避免使用 delete 方法。

## 内联缓存

```js
function loadX(o) {
    /**
    通常 V8 获取 o.x 的流程是这样的：查找对象 o 的隐藏类，再通过隐藏类查找 x 属性偏移
    量，然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 o.x
    流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x
    的属性值呢？答案是，有的。
     */
    return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6 };
for (var i = 0; i < 90000; i++) {
    loadX(o);
    loadX(o1);
}
```

### 什么是内联缓存

在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。

IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。

反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。

```js
function loadX(o) {
    o.y = 4;
    return o.x;
}
```

当 V8 执行这段函数的时候，它会判断 o.y = 4 和 return o.x 这两段是调用点 (CallSite)，因为它们使用了对象和属性，那么 V8 会在 loadX 函数的反馈向量中为每个调用点分配一个插槽。

每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，比如上面这个函数中的两个调用点都使用了对象 o，那么反馈向量两个插槽中的 map 属性也都是指向同一个隐藏类的，因此这两个插槽的 map 地址是一样的。

V8 除了缓存 o.x 这种 LOAD 类型的操作以外，还会缓存存储 (STORE) 类型和函数调用 (CALL) 类型的中间数据。

现在有了反馈向量缓存的数据，那 V8 是如何利用这些数据的呢？

当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return o.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 o.x 的属性值了。这样就大大提升了 V8 的执行效率。

### 多态和超态

```js
function loadX(o) {
    return o.x;
}
var o = { x: 1, y: 3 };
var o1 = { x: 3, y: 6, z: 4 };
for (var i = 0; i < 90000; i++) {
    loadX(o);
    loadX(o1);
}
```

我们可以看到，对象 o 和 o1 的形状是不同的，这意味着 V8 为它们创建的隐藏类也是不同的。

第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。

当 V8 再次执行 loadX 函数中的 o.x 语句时，同样会查找反馈向量表，发现第一个槽中记录了两个隐藏类。这时，V8 需要额外做一件事，那就是拿这个新的隐藏类和第一个插槽中的两个隐藏类来一一比较，如果新的隐藏类和第一个插槽中某个隐藏类相同，那么就使用该命中的隐藏类的偏移量。如果没有相同的呢？同样将新的信息添加到反馈向量的第一个插槽中。

如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态.
如果一个插槽中包含了 2～4 个隐藏类，那我们称这种状态为多态.
如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态.

### 尽量保持单态

单态的性能优于多态和超态, 稍微避免多态和超态的情况

要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(o)的函数，那么当传递参数时，尽量不要使用多个不同形状的 o 对象。




