# 第 7 章 RabbitMQ 集群

RabbitMQ 集群无缝封装了多台 RabbitMQ 服务器。在 Rabbi tMQ 集群里，运行时状态包含交换器、队列、绑定器、用户、虚拟主机以及策略，它们对所有节点都可用。由于这种共享运行时状态的特性，集群中的每个节点都能绑定、发布或者删除连接到第 一个节点时创建的交换器.

虽然 RabbitMQ 内建集群有不少优点，但是对其本身的限制和劣势的认识也很重要。首先，集群是按照低延迟环境进行设计的。千万不要跨越 WAN 或者互联网来搭建 RabbitMQ 集群。集群中的状态同步和跨节点的消息投递需要低延迟的通信 ， 只有 LAN 可以满足这一要求。

![图 67](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-19/pic_1658214688291-7.png)  

RabbitMQ 社区中的传统观念要求集群中节点数量 的上限在 32 到 64 个 。 记住，每向集群中新添加一个节点，你就为集群中的状态同步增加了更多的复杂性 。集群中的每个节点必须知道集群中其他节点。这种非线性的复杂度会拖慢跨节点的消息投递和集群的管理。

集群节点类型

- 磁盘节点
> 将集群的运行时状态会同时存储在内存和磁盘上
- 内存节点
> 仅将运行时状态信息存储在内存数据库中

节点类型和消息持久化

不论是哪种节点类型都不会影响消息持久化的行为。当通过消息属性 delivery-mode 将一条消息标记为持久化时，这条消息会被写入磁盘，而无关乎节点类型。因此，考虑磁盘 1/0 对 RabbitMQ 集群节点的影响就显得很尤为 重要。如果需要持久 化消息的话，你应当提供磁盘子系统来满足集群节点中队列写入速度的要求。

节点类型与崩溃行为

当节点或者集群崩溃时－，在磁盘节点启动并重新加入集群时，会被用来重建集群的运行时状态 。而对于内存节点来说，当加入集群时 则不会包含任何运行时状态数据。在重新加入集群时，集群中的其他节点会将诸如队列定义等信息发送给它。

状态节点

集群和队列行为
当消息发送到集群中的任何 一 个节点时，该消息会被路由到队列中去，无关乎队列在集群中的位置。当声明 一个队列时，该队列会在 RPC 请求 Queue.Declare 发送的集群节点上创建。选择在哪个节点上声明队列将对消息的吞吐量和性能造成影响。

消息发布的考量

无保障 - 故障通知 - 发送方确认 - 替代交换器 - HA 队列 - 支持事务 - 采用 HA 队列, 同时支持事务

![图 68](https://shubuzuo.coding.net/p/image-host/d/image-host/git/raw/master/images/2022-07/2022-07-19/pic_1658217005682-49.png)  






